<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Divine Sword â€” Michael vs Demons</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:#0b0d10; --fg:#e8eef2; --muted:#9aa6b2; --accent:#36c; --danger:#e34; --ok:#3c8;
    --hud-bg:rgba(0,0,0,0.45); --card:rgba(15,18,22,0.9);
  }
  html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui,Segoe UI,Roboto,Arial; }
  #wrap { position:relative; width:100vw; height:100vh; overflow:hidden; }
  canvas { 
    display:block; width:100%; height:100%; 
    background: 
      radial-gradient(circle at 20% 30%, rgba(40,15,15,0.8) 0%, transparent 50%),
      radial-gradient(circle at 80% 20%, rgba(30,10,10,0.6) 0%, transparent 40%),
      radial-gradient(circle at 40% 80%, rgba(25,8,8,0.7) 0%, transparent 45%),
      radial-gradient(circle at 70% 70%, rgba(35,12,12,0.5) 0%, transparent 35%),
      linear-gradient(135deg, #0a0505 0%, #1a0808 25%, #0f0404 50%, #1c0909 75%, #080303 100%),
      radial-gradient(ellipse at center, #1a0606 0%, #0d0404 40%, #050202 100%);
  }
  /* HUD - Medieval Gothic Style - Bottom Center */
  .hud { 
    position:absolute; left:50%; bottom:20px; transform:translateX(-50%); display:flex; gap:24px; flex-wrap:nowrap; user-select:none; 
    font-family: 'Cinzel', 'UnifrakturMaguntia', 'Times New Roman', serif;
    align-items: center;
    z-index: 1000;
  }
  
  /* Kills Counter - Bottom Center */
  .hud .badge {
    background: transparent;
    padding: 0;
    border-radius: 0;
    box-shadow: none;
    border: none;
    background: transparent;
    box-shadow: none;
  }
  .badge { 
    background: transparent; 
    padding: 0; 
    border-radius: 0; 
    box-shadow: none;
    position: relative;
  }
  .row { display:flex; gap:8px; align-items:center; }
  

  
  /* Gothic Text Styling */
  .muted { 
    color: #ffffff; 
    font-weight: 600;
    text-shadow: 
      0 0 12px rgba(255,255,255,0.4),
      0 2px 4px rgba(0,0,0,0.8);
    letter-spacing: 1px;
    /* Premium text effects */
    background: linear-gradient(45deg, #fff, #ccc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .zleft { 
    color: #ffffff; 
    font-weight: 700;
    font-size: 20px;
    text-shadow: 
      0 0 16px rgba(255,255,255,0.6),
      0 2px 6px rgba(0,0,0,0.9);
    letter-spacing: 1px;
    /* Premium text effects */
    background: linear-gradient(45deg, #fff, #ccc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  /* Premium 3D Circular Meters - Corner Positioned */
  .circular-meter {
    position: fixed;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    z-index: 1000;
  }
  
  /* Health Meter - Bottom Left */
  .health-meter {
    left: 30px;
    bottom: 30px;
  }
  
  /* Fury Meter - Bottom Right */
  .fury-meter {
    right: 30px;
    bottom: 30px;
  }
  
  .meter-frame {
    position: relative;
    width: 140px;
    height: 140px;
    border-radius: 50%;
    background: 
      radial-gradient(circle at 25% 25%, #666 0%, #444 20%, #222 50%, #111 80%, #000 100%),
      radial-gradient(circle at 75% 75%, #333 0%, #111 60%, #000 100%);
    box-shadow: 
      /* Multiple shadow layers for premium 3D depth */
      inset 0 4px 8px rgba(255,255,255,0.2),
      inset 0 -4px 8px rgba(0,0,0,0.98),
      inset 0 0 25px rgba(0,0,0,0.9),
      0 15px 30px rgba(0,0,0,0.95),
      0 8px 16px rgba(0,0,0,0.8),
      0 4px 8px rgba(0,0,0,0.6),
      0 2px 4px rgba(0,0,0,0.4),
      /* Floating effect with ambient shadows */
      0 0 50px rgba(0,0,0,0.5);
    border: 4px solid;
    overflow: hidden;
    /* Premium metallic texture */
    background-image: 
      linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%),
      radial-gradient(circle at 25% 25%, #666 0%, #444 20%, #222 50%, #111 80%, #000 100%);
  }
  
  .meter-fill {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: conic-gradient(from 0deg, transparent 0deg, var(--fill-color) var(--fill-angle), transparent var(--fill-angle));
    transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    transform: rotate(-90deg);
    /* Premium fill effects */
    box-shadow: 
      inset 0 3px 6px rgba(255,255,255,0.4),
      inset 0 -3px 6px rgba(0,0,0,0.6),
      inset 0 0 15px rgba(0,0,0,0.3);
  }
  
  .meter-glow {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: 
      radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2) 0%, transparent 50%),
      radial-gradient(circle at 70% 70%, rgba(0,0,0,0.3) 0%, transparent 50%);
    pointer-events: none;
    /* Enhanced glow with multiple layers */
    filter: blur(1px);
  }
  
  /* Premium Health Meter */
  .health-meter .meter-frame {
    border-color: #000;
    background-image: 
      linear-gradient(45deg, transparent 30%, rgba(0,255,0,0.1) 50%, transparent 70%),
      radial-gradient(circle at 25% 25%, #666 0%, #444 20%, #222 50%, #111 80%, #000 100%);
    box-shadow: 
      inset 0 4px 8px rgba(255,255,255,0.2),
      inset 0 -4px 8px rgba(0,0,0,0.98),
      inset 0 0 25px rgba(0,0,0,0.9),
      0 15px 30px rgba(0,0,0,0.95),
      0 8px 16px rgba(0,0,0,0.8),
      0 4px 8px rgba(0,0,0,0.6),
      0 2px 4px rgba(0,0,0,0.4),
      0 0 50px rgba(0,0,0,0.5),
      0 0 40px rgba(0,255,0,0.4);
  }
  
  .health-meter .meter-fill {
    --fill-color: #00ff00;
    --fill-angle: 0deg;
    background: conic-gradient(from 0deg, #00ff00 0deg, #00ff00 var(--fill-angle), #008800 calc(var(--fill-angle) + 20deg), transparent calc(var(--fill-angle) + 20deg));
  }
  
  /* Premium Fury Meter */
  .fury-meter .meter-frame {
    border-color: #000;
    background-image: 
      linear-gradient(45deg, transparent 30%, rgba(255,0,0,0.1) 50%, transparent 70%),
      radial-gradient(circle at 25% 25%, #666 0%, #444 20%, #222 50%, #111 80%, #000 100%);
    box-shadow: 
      inset 0 4px 8px rgba(255,255,255,0.2),
      inset 0 -4px 8px rgba(0,0,0,0.98),
      inset 0 0 25px rgba(0,0,0,0.9),
      0 15px 30px rgba(0,0,0,0.95),
      0 8px 16px rgba(0,0,0,0.8),
      0 4px 8px rgba(0,0,0,0.6),
      0 2px 4px rgba(0,0,0,0.4),
      0 0 50px rgba(0,0,0,0.5),
      0 0 40px rgba(255,0,0,0.4);
  }
  
  .fury-meter .meter-fill {
    --fill-color: #ff0000;
    --fill-angle: 0deg;
    background: conic-gradient(from 0deg, #ff0000 0deg, #ff0000 var(--fill-angle), #cc0000 calc(var(--fill-angle) + 20deg), transparent calc(var(--fill-angle) + 20deg));
  }
  

  
  /* Premium Meter Labels */
  .meter-label {
    color: #ffffff; 
    font-weight: 700;
    font-size: 20px;
    text-shadow: 
      0 0 16px rgba(255,255,255,0.6),
      0 2px 6px rgba(0,0,0,0.9);
    margin-top: 12px;
    letter-spacing: 1px;
    /* Premium text effects */
    background: linear-gradient(45deg, #fff, #ccc);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  
  /* Enhanced Full Meter Glow Effects */
  .circular-meter.full .meter-frame {
    box-shadow: 
      inset 0 3px 6px rgba(255,255,255,0.15),
      inset 0 -3px 6px rgba(0,0,0,0.95),
      inset 0 0 20px rgba(0,0,0,0.8),
      0 12px 24px rgba(0,0,0,0.9),
      0 6px 12px rgba(0,0,0,0.7),
      0 3px 6px rgba(0,0,0,0.5),
      0 1px 2px rgba(0,0,0,0.3),
      0 0 40px rgba(0,0,0,0.4),
      0 0 50px var(--glow-color);
    animation: premiumGlow 2s ease-in-out infinite alternate;
  }
  
  .health-meter.full {
    --glow-color: rgba(0,255,0,0.8);
  }
  
  .fury-meter.full {
    --glow-color: rgba(255,102,0,0.8);
  }
  
  /* Premium Glow Animation */
  @keyframes premiumGlow {
    0% { 
      box-shadow: 
        inset 0 3px 6px rgba(255,255,255,0.15),
        inset 0 -3px 6px rgba(0,0,0,0.95),
        inset 0 0 20px rgba(0,0,0,0.8),
        0 12px 24px rgba(0,0,0,0.9),
        0 6px 12px rgba(0,0,0,0.7),
        0 3px 6px rgba(0,0,0,0.5),
        0 1px 2px rgba(0,0,0,0.3),
        0 0 40px rgba(0,0,0,0.4),
        0 0 50px var(--glow-color);
    }
    100% { 
      box-shadow: 
        inset 0 3px 6px rgba(255,255,255,0.15),
        inset 0 -3px 6px rgba(0,0,0,0.95),
        inset 0 0 20px rgba(0,0,0,0.8),
        0 12px 24px rgba(0,0,0,0.9),
        0 6px 12px rgba(0,0,0,0.7),
        0 3px 6px rgba(0,0,0,0.5),
        0 1px 2px rgba(0,0,0,0.3),
        0 0 40px rgba(0,0,0,0.4),
        0 0 80px var(--glow-color);
    }
  }
  /* Overlays */
  .overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; }
  .panel { background:var(--card); border:1px solid #1d232a; padding:22px 26px; border-radius:14px; width:min(560px,90vw); box-shadow:0 12px 40px rgba(0,0,0,.45); }
  h1 { margin:0 0 10px; font-size:28px; font-weight:700; letter-spacing:.3px; }
  h2 { margin:14px 0 6px; font-size:18px; font-weight:700; }
  .grid { display:grid; grid-template-columns:1fr 1fr; gap:10px 16px; }
  kbd { background:#11161b; border:1px solid #212a33; border-bottom-color:#1a2229; padding:2px 6px; border-radius:6px; font-size:12px; }
  .btn { display:inline-block; padding:10px 14px; border-radius:10px; background:#1a2330; border:1px solid #253042; cursor:pointer; text-align:center; }
  .btn.primary { background:#1e2f4a; border-color:#2f4771; }
  .center { text-align:center; }
  .shoprow { display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px dashed #253042; }
  .shoprow:last-child { border:0; }
  .dim { opacity:.7; }
  .foot { margin-top:10px; color:var(--muted); font-size:12px; }
  

</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>

  <!-- HUD -->
  <div class="hud" id="hud" hidden>
    <div class="badge row">
      <span class="muted">Kills</span>&nbsp;<b class="zleft" id="hudZLeft">0</b>
    </div>
  </div>

  <!-- Independent Circular Meters -->
  <!-- Health Meter - Bottom Left -->
  <div class="circular-meter health-meter">
    <div class="meter-frame">
      <div class="meter-fill" id="hpBar"></div>
      <div class="meter-glow"></div>
    </div>
    <div class="meter-label">Health</div>
  </div>

  <!-- Fury Meter - Bottom Right -->
  <div class="circular-meter fury-meter">
    <div class="meter-frame">
      <div class="meter-fill" id="furyBar"></div>
      <div class="meter-glow"></div>
    </div>
    <div class="meter-label">Fury</div>
  </div>



  <!-- Start Panel - REMOVED for pure gameplay -->

  <!-- Shop Panel - REMOVED for pure gameplay -->

  <!-- Game Over Panel - REMOVED for seamless gameplay -->
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // UI elements
  const hud = {
    root: document.getElementById('hud'),
    zleft: document.getElementById('hudZLeft'),
    hpBar: document.getElementById('hpBar'),
    furyBar: document.getElementById('furyBar'), // Add fury bar
  };
  

  
  // All overlays removed for pure gameplay
  
  // No overlay buttons needed for pure gameplay

  // Globals
  let W=0,H=0, DPR=1, tPrev=0, accTime=0;

  const RNG = mulberry32(Date.now() % 2147483647);
  function mulberry32(a){return function(){a|=0;a=a+0x6D2B79F5|0;var t=Math.imul(a^a>>>15,1|a);t=t+Math.imul(t^t>>>7,61|t)^t;return ((t^t>>>14)>>>0)/4294967296}}
  const TAU = Math.PI * 2;
  const clamp = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));
  const lerp = (a,b,x)=>a+(b-a)*x;
  const dist2 = (ax,ay,bx,by)=>{const dx=ax-bx, dy=ay-by; return dx*dx+dy*dy;}
  const angleTo = (ax,ay,bx,by)=>Math.atan2(by-ay,bx-ax);
  const lineCircle = (ox,oy,dx,dy,cx,cy,r)=>{
    // Ray origin o, dir d normalized, circle c,r. Return distance or null.
    const fx = ox - cx, fy = oy - cy;
    const b = 2*(dx*fx + dy*fy);
    const c = fx*fx + fy*fy - r*r;
    let disc = b*b - 4*c;
    if (disc < 0) return null;
    disc = Math.sqrt(disc);
    const t1 = (-b - disc)/2;
    const t2 = (-b + disc)/2;
    const t = (t1 >= 0) ? t1 : (t2 >= 0 ? t2 : null);
    return t;
  };

  // Config
  const CFG = {
    arena: { w: 2200, h: 1400, wallPad: 0 },
    player: {
      radius: 20, speed: 300, friction: 0.86,
      hpMax: 120,
      rollDistance: 180, rollSpeed: 900, rollCooldown: 2.0, // 3x radius, 3x speed, 2s cooldown
      swordDamage: 75, swordRange: 150, swordCooldown: 0.15, // Divine sword stats (buffed)

      burstDamage: 120, burstRange: 200, burstCooldown: 5.0, // Heavenly burst stats
      upgradeLevel: 0, // Current upgrade level
      upgradeMultiplier: 1.0, // Damage multiplier from upgrades
    },
    demons: {
      imp: { hp:100, spd:120, rad:22, favor:4, explodeOnContact: true, explosionDamage: 35, explosionRadius: 80 },
      hellhound: { hp:80, spd:200, rad:20, favor:5, explodeOnContact: true, explosionDamage: 50, explosionRadius: 100 },
      fallen:  { hp:300, spd:90,  rad:30, favor:12, explodeOnContact: true, explosionDamage: 80, explosionRadius: 120 },
      knockback: 80,
    },
    waves: { spawnMaxRate:4, baseCount:8, curve:1.25, addPerWave:3, hpScale:0.06 },
          drop: { chance:0.20 },

    progression: { 
      favorMultiplier: 1.0, // Increases with waves
      upgradeCost: 50, // Cost to upgrade weapons
      maxUpgrades: 5 // Maximum upgrade level
    },
    intermissionSec: 12,
  };

  // No obstacles needed

  // Game state
  let state='menu';
  let isPaused = false;
  const game = {
    wave:1, zToSpawn:0, zSpawned:0, zAlive:0, spawnRate:1.5, spawnAcc:0,
    hp:0, hpMax:0, pos:{x:0,y:0}, vel:{x:0,y:0}, ang:0,
          currentWeapon:'sword', // sword is primary weapon
          swordCd:0, burstCd:0, // Weapon cooldowns
    bossWave:false, // Boss wave flag
    upgradeLevel:0, // Current upgrade level
    kills:0, hits:0,
 scrap:0, startTime:0, endTime:0, bestWave: Number(localStorage.getItem('bestWave')||0),
    shopTimer: null, // Added for shop timer management
    rolling:false, rollT:0, rollDir:{x:0,y:0}, rollCd:0, // Roll mechanics
  };

  // Entities
  const zombies = []; // {x,y,vx,vy,sp,rad,hp,type, staggerT}
  const tracers = []; // {x,y,x2,y2,ttl,type}
  const particles = []; // {x,y,vx,vy,life,lifeMax,color,size}
  const bloodPools = []; // {x,y,size,life,lifeMax}

  // Input
  const keys = new Set();
  const mouse = { x:0, y:0, worldX:0, worldY:0, down:false, rdown:false };
  let padAim = {x:0,y:0};
  let usingPad = false;

  // Camera
  const cam = { x:0, y:0, shake:0, zoom:1 };

  // Event listeners
  window.addEventListener('resize', onResize);
  onResize();
  

  
  // Fullscreen change detection
  document.addEventListener('fullscreenchange', () => {
    if (document.fullscreenElement) {
      console.log('Entered fullscreen');
    } else {
      console.log('Exited fullscreen');
    }
  });

  window.addEventListener('keydown', (e)=>{
    if (['F5','F12'].includes(e.code)) return;
    
    // Fullscreen exit with ESC
    if (e.code === 'Escape') {
      if (document.fullscreenElement) {
        document.exitFullscreen();
        return;
      }
    }
    
    // Pause system with Shift key
    if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
      if (state === 'playing') {
        isPaused = !isPaused;
        console.log('Pause toggled:', isPaused);
        return;
      }
    }
    
    // Restart when paused with Enter
    if (isPaused && e.code === 'Enter') {
      console.log('Restarting with Enter key');
      isPaused = false;
      startGame();
      return;
    }
    
    keys.add(e.code);
    // Resume game with R key when paused
    if (e.code === 'KeyR' && isPaused && state === 'playing') {
      resumeGame();
      return;
    }
    
    // No menu/shop states in pure gameplay mode
    if (state==='playing' && !isPaused) {
      if (e.code==='KeyE') tryHeavenlyBurst();
      if (e.code==='KeyT') upgradeWeapon();
    }
  });
  window.addEventListener('keyup', (e)=>keys.delete(e.code));
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - rect.left) * DPR;
    mouse.y = (e.clientY - rect.top) * DPR;
  });
  canvas.addEventListener('mousedown',(e)=>{ 
    if (e.button===0) mouse.down=true; 
    if (e.button===2) {
      mouse.rdown=true;
      // Right-click for abilities (not restart)
      // Abilities handled in updateGame()
    }
  });
  canvas.addEventListener('contextmenu',(e)=>e.preventDefault());
  canvas.addEventListener('mouseup',(e)=>{ if (e.button===0) mouse.down=false; if (e.button===2) mouse.rdown=false; });
  // Removed problematic pointer lock that was hiding mouse cursor
  // document.getElementById('wrap').addEventListener('pointerdown', ()=>canvas.requestPointerLock?.());

  // Gamepad polling
  window.addEventListener('gamepadconnected',()=>{ usingPad=true; });
  window.addEventListener('gamepaddisconnected',()=>{ usingPad=false; });

  // Auto-start game immediately for pure gameplay
  function initGame() {
    // Start game immediately - no menus, no popups!
    startGame();
  }
  
  // Initialize on page load
  initGame();

  // Main loop
  requestAnimationFrame(loop);
  function loop(t){
    const dt = Math.min(0.033, (t - (tPrev||t)) / 1000); // clamp dt
    tPrev = t;

    // FPS calc



    // Update input from gamepad
    if (!isPaused) readGamepad();

    if (state==='playing' && !isPaused) updateGame(dt);
    
    // Debug: Log current state every 60 frames (1 second)
    if (Math.floor(t/16.67) % 60 === 0) {
      console.log('Game Loop - State:', state, 'Paused:', isPaused);
    }
    
    render();

    requestAnimationFrame(loop);
  }

  function startGame(){
    // Reset
    zombies.length = 0; tracers.length = 0; particles.length = 0; bloodPools.length = 0;
    Object.assign(game, {
      totalKills:0, zAlive:0, spawnRate:1.5, spawnAcc:0,
      hp:CFG.player.hpMax, hpMax:CFG.player.hpMax,
      pos:{x:0,y:0}, vel:{x:0,y:0}, ang:0,
      currentWeapon:'sword',
      swordCd:0, burstCd:0,
      fury:0, // Add fury variable
      holyInfernoCd:0, // Add cooldown variable

      upgradeLevel:0,
      kills:0, hits:0,
      startTime: performance.now(), endTime: 0,
      shopTimer: null, // Clear shop timer on game start
      rolling:false, rollT:0, rollDir:{x:0,y:0}, rollCd:0, // Reset roll mechanics
    });
    cam.x = cam.y = 0; cam.shake = 0; cam.zoom = 1;

    // Reset pause state
    console.log('startGame: Resetting pause state');
    isPaused = false;
    console.log('startGame: Pause state reset');

    // Show HUD and start game immediately
    hud.root.hidden = false;
    state='playing';
    updateHUD();
    
    // Auto-fullscreen removed due to browser security restrictions
    // User must manually click fullscreen button for immersive experience
  }

  function gameOver(){
    // Clear any existing shop timer
    if (game.shopTimer) {
      clearInterval(game.shopTimer);
      game.shopTimer = null;
    }
    
    state='gameOver';
    game.endTime = performance.now();

    const secs = ((game.endTime - game.startTime)/1000)|0;
    const acc = game.shots ? Math.round(100*game.hits/game.shots) : 0;
    if (game.wave-1 > game.bestWave) { game.bestWave = game.wave-1; localStorage.setItem('bestWave', String(game.bestWave)); }

    // Show death stats in HUD briefly
    const statsText = `ðŸ‘¼ WAVE ${game.wave-1} | DEMONS SLAIN ${game.kills} | ${acc}% ACC | ${secs}s | BEST ${game.bestWave}`;
    
    // Create temporary stats display in HUD
    const statsDiv = document.createElement('div');
    statsDiv.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.8); padding:20px; border-radius:10px; color:#fff; font-size:18px; text-align:center; z-index:1000;';
    statsDiv.innerHTML = `
      <div style="margin-bottom:10px; font-size:24px; color:#ffd700;">ðŸ‘¼ DIVINE MISSION COMPLETE</div>
      <div>${statsText}</div>
      <div style="margin-top:10px; color:#888; font-size:14px;">Restarting in 3 seconds...</div>
    `;
    document.body.appendChild(statsDiv);
    
    // Auto-restart after 3 seconds
    setTimeout(() => {
      if (document.body.contains(statsDiv)) {
        document.body.removeChild(statsDiv);
      }
      startGame();
    }, 3000);
  }

  function setupWave(){
    const w = game.wave;
    const n = Math.ceil(CFG.waves.baseCount + CFG.waves.addPerWave*Math.pow(w, CFG.waves.curve));
    
    // Progressive demon mix based on wave
    const mixImp = lerp(0.70, 0.30, clamp((w-1)/30,0,1));
    const mixHellhound = lerp(0.25, 0.45, clamp((w-1)/30,0,1));
    const mixFallen = lerp(0.05, 0.25, clamp((w-1)/30,0,1));
    
    game.zToSpawn = n;
    game.zSpawned = 0;
    game.zAlive = 0;
    game.spawnRate = Math.min(1.5 + 0.15*w, CFG.waves.spawnMaxRate);
    game.spawnAcc = 0;

    // Prebuild a spawn bag with types
    game.spawnBag = [];
    const addType = (t, count)=>{ for(let i=0;i<count;i++) game.spawnBag.push(t); };
    addType('imp', Math.round(n*mixImp));
    addType('hellhound', Math.round(n*mixHellhound));
    addType('fallen', Math.round(n*mixFallen));
    shuffle(game.spawnBag);

    // Boss wave every 10 waves
    if (w % 10 === 0) {
      game.bossWave = true;
      game.zToSpawn += 5; // Extra demons for boss wave
    } else {
      game.bossWave = false;
    }

    // heal a bit at wave start
    game.hp = clamp(game.hp + 20, 0, game.hpMax);
  }

  // Shop functionality removed for pure gameplay

  function updateGame(dt){
    // Progressive spawn logic - no wave limits
    // Spawn rate increases with total kills
    const baseSpawnRate = 1.5;
    const killMultiplier = 0.1;
    game.spawnRate = baseSpawnRate + (game.totalKills * killMultiplier);
    
    // Always spawn demons continuously
    game.spawnAcc += dt * game.spawnRate;
    while (game.spawnAcc >= 1) {
      // Choose demon type based on kill progression
      const demonType = chooseDemonType(game.totalKills);
      spawnDemon(demonType);
      game.zAlive++;
      game.spawnAcc -= 1;
    }

    // Input movement
    const want = {x:0,y:0};
    if (keys.has('KeyW') || keys.has('ArrowUp')) want.y -= 1;
    if (keys.has('KeyS') || keys.has('ArrowDown')) want.y += 1;
    if (keys.has('KeyA') || keys.has('ArrowLeft')) want.x -= 1;
    if (keys.has('KeyD') || keys.has('ArrowRight')) want.x += 1;

    // Gamepad moves
    if (usingPad) {
      want.x += padMove.x;
      want.y += padMove.y;
    }

    // Normalize
    const len = Math.hypot(want.x, want.y) || 1;
    want.x /= len; want.y /= len;

    // Roll mechanics - No cooldown, instant response!
    const wantRoll = keys.has('Space') || (usingPad && padSprint);
    
    // Trigger roll - Instant, unlimited!
    if (wantRoll && !game.rolling && (want.x||want.y)) {
      game.rolling = true;
      game.rollT = CFG.player.rollDistance / CFG.player.rollSpeed;
      game.rollDir.x = want.x;
      game.rollDir.y = want.y;
      // game.rollCd = CFG.player.rollCooldown; // Cooldown removed!
    }

    // Handle rolling movement
    let spd = CFG.player.speed;
    let moveX = want.x, moveY = want.y;
    
    if (game.rolling) {
      game.rollT -= dt;
      if (game.rollT <= 0) {
        game.rolling = false;
      } else {
        // Override movement with roll direction and speed
        spd = CFG.player.rollSpeed;
        moveX = game.rollDir.x;
        moveY = game.rollDir.y;
      }
    }

    // Velocity & collision
    game.vel.x = lerp(game.vel.x, moveX * spd, 0.8);
    game.vel.y = lerp(game.vel.y, moveY * spd, 0.8);

    // No collision - Michael passes through everything
    game.pos.x += game.vel.x * dt;
    game.pos.y += game.vel.y * dt;
    
    // Boundary system - allow full arena access
    const boundary = 800; // Increased from 400 to 800 for full arena access
    game.pos.x = clamp(game.pos.x, -boundary, boundary);
    game.pos.y = clamp(game.pos.y, -boundary, boundary);

    // Aim angle
    if (!usingPad || (Math.abs(padAim.x)+Math.abs(padAim.y) < 0.2)) {
      // Mouse aim
      screenToWorld(mouse.x, mouse.y, (wx,wy)=>{ mouse.worldX=wx; mouse.worldY=wy; });
      game.ang = angleTo(game.pos.x, game.pos.y, mouse.worldX, mouse.worldY);
    } else {
      // Pad aim
      game.ang = Math.atan2(padAim.y, padAim.x);
    }

    // ADS removed - not needed for divine weapons

    // Weapon cooldowns
    game.swordCd = Math.max(0, game.swordCd - dt);
    game.burstCd = Math.max(0, game.burstCd - dt);
    game.holyInfernoCd = Math.max(0, game.holyInfernoCd - dt); // Add fury cooldown

    // Left-click for Fury Generation
    const wantFire = mouse.down || (usingPad && padFire);
    if (wantFire) {
      console.log('Left-click detected, calling generateFury');
      generateFury();
    }
    
    // Right-click for Fury Spending
    const wantDecimate = mouse.rdown || (usingPad && padDecimate);
    if (wantDecimate) {
      console.log('Right-click detected, calling tryFire');
      tryFire();
    }

    // Weapon switching
    if (keys.has('KeyR')) switchWeapon();

    // Zombies behavior
    for (let i=zombies.length-1; i>=0; i--){
      const z = zombies[i];
      // Seek player
      const ang = angleTo(z.x, z.y, game.pos.x, game.pos.y);
      const sp = z.sp;
      if (z.staggerT>0){ z.staggerT -= dt; }
      const k = z.staggerT>0 ? 0.35 : 1;
      z.vx = Math.cos(ang)*sp*k;
      z.vy = Math.sin(ang)*sp*k;

      // No collision - demons pass through everything
      z.x += z.vx * dt;
      z.y += z.vy * dt;

      // Attack if close (but not during roll - player phases through)
      if (!game.rolling) {
        const d2 = dist2(z.x,z.y, game.pos.x, game.pos.y);
        const rr = (z.rad + CFG.player.radius + 2);
        if (d2 < rr*rr){
          // Contact explosion for explosive demons
          if (CFG.demons[z.type]?.explodeOnContact) {
            explodeDemon(z, z.x, z.y);
            // Remove the demon after explosion
            zombies.splice(i, 1);
            game.zAlive--;
            continue; // Skip the rest of the loop for this demon
          } else {
            // Regular damage over time for non-explosive demons
            const dps = (z.type==='fallen') ? 35 : (z.type==='hellhound' ? 22 : 14);
            applyDamage(dps*dt);
            // cam.shake = Math.max(cam.shake, 6); // Camera shake removed
          }
        }
      }

      if (z.hp <= 0){
        // Death particles
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * TAU;
          const speed = 80 + RNG() * 60;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const colors = ['#ff4444', '#8b0000', '#ff0000'];
          const color = colors[Math.floor(RNG() * colors.length)];
          createParticle(z.x, z.y, vx, vy, 0.5, color, 3);
        }
        
        // Drop
        onDemonKilled(z);
        zombies.splice(i,1);
        game.zAlive--;
      }
    }

    // Tracers fade
    for (let i=tracers.length-1;i>=0;i--){ const tr=tracers[i]; tr.ttl-=dt; if (tr.ttl<=0) tracers.splice(i,1); }
    
    // Update particles
    updateParticles(dt);
    
    // Update blood pools
    updateBloodPools(dt);
    
    // Ambient hell particles
    if (RNG() < 0.1) {
      const side = Math.floor(RNG() * 4);
      let x, y;
      if (side === 0) { x = -CFG.arena.w/2; y = (RNG()-0.5) * CFG.arena.h; }
      if (side === 1) { x = CFG.arena.w/2; y = (RNG()-0.5) * CFG.arena.h; }
      if (side === 2) { y = -CFG.arena.h/2; x = (RNG()-0.5) * CFG.arena.w; }
      if (side === 3) { y = CFG.arena.h/2; x = (RNG()-0.5) * CFG.arena.w; }
      
      const vx = (game.pos.x - x) * 0.1;
      const vy = (game.pos.y - y) * 0.1;
      const colors = ['#ff4400', '#ff6600', '#ff8800'];
      const color = colors[Math.floor(RNG() * colors.length)];
      createParticle(x, y, vx, vy, 3.0, color, 2);
    }

    // Drops removed - no more collectibles

    // Camera follow - LOCKED on Michael
    cam.x = game.pos.x; // Direct lock, no lerp
    cam.y = game.pos.y; // Direct lock, no lerp
    cam.zoom = 1.0; // Fixed zoom, no ADS zoom
    if (cam.shake>0) cam.shake = Math.max(0, cam.shake - 40*dt);

    // Recoil system removed - not needed for divine weapons

    // Update HUD
    updateHUD();

    // Die
    if (game.hp<=0) gameOver();
  }

  function generateFury(){
    // LEFT-CLICK: FURY STRIKE - Circular AOE + fury generation
    // Small cooldown to prevent spam
    
    if (game.holyInfernoCd > 0) return; // Small cooldown check
    
    game.holyInfernoCd = 0.3; // 0.3 second cooldown
    game.hits++;
    // cam.shake = Math.max(cam.shake, 20); // Camera shake removed
    
    // Circular AOE damage (200-unit radius - reduced for balance)
    const sweepRange = 200;
    let furyGained = 0;
    
    // Generate fury even without demons (for testing)
    furyGained = 5; // Reduced base fury generation
    
    for (const z of zombies){
      const dist = Math.hypot(z.x - game.pos.x, z.y - game.pos.y);
      if (dist <= sweepRange){
        const baseDamage = Math.round((5 + (game.upgradeLevel * 3)) * 5); // 5x damage: ~25-225
        const totalDamage = baseDamage; // No Divine Favor bonus
        
        z.hp -= totalDamage;
        game.hits++;
        
        // Generate fury per hit (max 100) - reduced
        furyGained += 3;
        
        // Knockback
        const kb = CFG.demons.knockback;
        const ang = angleTo(game.pos.x, game.pos.y, z.x, z.y);
        z.x += Math.cos(ang) * 0.6 * (kb/60);
        z.y += Math.sin(ang) * 0.6 * (kb/60);
        z.staggerT = 0.2;
      }
    }
    
    // Add fury (capped at 100)
    game.fury = Math.min(100, game.fury + furyGained);
    console.log('generateFury: Generated fury:', furyGained, 'Total fury:', game.fury);
    
    // Visual effects - flaming ember swirl
    for (let i = 0; i < 24; i++) {
      const angle = (i / 24) * TAU;
      const speed = 200 + RNG() * 150;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const colors = ['#ff4400', '#ff6600', '#ff8800'];
      const color = colors[Math.floor(RNG() * colors.length)];
      createParticle(game.pos.x, game.pos.y, vx, vy, 1.0, color, 4);
    }
    
    // Add tracer for visual feedback
    tracers.push({x:game.pos.x, y:game.pos.y, x2:game.pos.x, y2:game.pos.y, ttl:0.6, type:'holyEmber'});
  }

  function tryFire(){
    // RIGHT-CLICK: RESERVED FOR FUTURE SKILL
    // Placeholder function - ready for new ability design
    console.log('Right-click: Future skill slot ready');
  }

  function trySwordSlash(){
    if (game.swordCd > 0) return;
    
    game.swordCd = CFG.player.swordCooldown;
    game.hits++;
    // cam.shake = Math.max(cam.shake, 15); // Camera shake removed
    
    // DARIUS Q DECIMATE: 360Â° circular swing with inner handle vs outer blade
    const slashRange = CFG.player.swordRange;
    const innerRadius = slashRange * 0.4; // Inner handle area (40% of range)
    const outerRadius = slashRange;        // Outer blade area (100% of range)
    
    // Check all demons in range
    for (const z of zombies){
      const dist = Math.hypot(z.x - game.pos.x, z.y - game.pos.y);
      if (dist <= slashRange){
        let dmg = 0;
        let isBladeHit = false;
        
        if (dist <= innerRadius) {
          // INNER HANDLE: Reduced damage (40% of normal)
          dmg = Math.round(CFG.player.swordDamage * 0.4 * CFG.player.upgradeMultiplier);
        } else {
          // OUTER BLADE: Full damage + healing potential
          dmg = Math.round(CFG.player.swordDamage * CFG.player.upgradeMultiplier);
          isBladeHit = true;
          
          // HEALING: Heal based on missing health when blade hits
          if (game.hp < game.hpMax) {
            const missingHealth = game.hpMax - game.hp;
            const healAmount = Math.round(missingHealth * 0.15); // 15% of missing health
            game.hp = Math.min(game.hpMax, game.hp + healAmount);
          }
        }
        
        z.hp -= dmg;
        game.hits++;
        
        // Enhanced knockback for blade hits
        const kb = CFG.demons.knockback;
        const ang = angleTo(game.pos.x, game.pos.y, z.x, z.y);
        const knockbackMultiplier = isBladeHit ? 1.2 : 0.8; // Blade hits harder
        z.x += Math.cos(ang) * knockbackMultiplier * (kb/60);
        z.y += Math.sin(ang) * knockbackMultiplier * (kb/60);
        z.staggerT = isBladeHit ? 0.25 : 0.15; // Blade hits stagger longer
        
        // Visual feedback for blade vs handle hits
        if (isBladeHit) {
          // Blade hit particles (golden)
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * TAU;
            const speed = 150 + RNG() * 100;
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed;
            createParticle(z.x, z.y, vx, vy, 0.6, '#ffd700', 5);
          }
        } else {
          // Handle hit particles (dull)
          for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * TAU;
            const speed = 80 + RNG() * 60;
            const vx = Math.cos(angle) * speed;
            const vy = Math.sin(angle) * speed;
            createParticle(z.x, z.y, vx, vy, 0.4, '#666666', 3);
          }
        }
      }
    }
    
    // VISUAL EFFECTS for Darius Q Decimate
    
    // 1. 360Â° Swing Tracers
    const swingStages = 12; // 12 stages for smooth 360Â° motion
    for (let i = 0; i < swingStages; i++) {
      const angle = (i / swingStages) * TAU;
      const nextAngle = ((i + 1) / swingStages) * TAU;
      // Inner handle tracer
      const innerX1 = game.pos.x + Math.cos(angle) * innerRadius;
      const innerY1 = game.pos.y + Math.sin(angle) * innerRadius;
      const innerX2 = game.pos.x + Math.cos(nextAngle) * innerRadius;
      const innerY2 = game.pos.y + Math.sin(nextAngle) * innerRadius;
      
      tracers.push({
        x: innerX1, y: innerY1,
        x2: innerX2, y2: innerY2,
        ttl: 0.4, type: 'decimateHandle'
      });
      
      // Outer blade tracer
      const outerX1 = game.pos.x + Math.cos(angle) * outerRadius;
      const outerY1 = game.pos.y + Math.sin(angle) * outerRadius;
      const outerX2 = game.pos.x + Math.cos(nextAngle) * outerRadius;
      const outerY2 = game.pos.y + Math.sin(nextAngle) * outerRadius;
      
      tracers.push({
        x: outerX1, y: outerY1,
        x2: outerX2, y2: outerY2,
        ttl: 0.5, type: 'decimateBlade'
      });
    }
    
    // 2. Swing Progression Particles
    for (let i = 0; i < swingStages; i++) {
      const angle = (i / swingStages) * TAU;
      const progress = i / swingStages;
      
      // Handle particles (dull, inner)
      for (let j = 0; j < 3; j++) {
        const particleAngle = angle + (j / 3) * (TAU / swingStages);
        const radius = innerRadius * (0.8 + RNG() * 0.4);
        const x = game.pos.x + Math.cos(particleAngle) * radius;
        const y = game.pos.y + Math.sin(particleAngle) * radius;
        const vx = Math.cos(particleAngle) * 60;
        const vy = Math.sin(particleAngle) * 60;
        createParticle(x, y, vx, vy, 0.5, '#666666', 4);
      }
      
      // Blade particles (bright, outer)
      for (let j = 0; j < 5; j++) {
        const particleAngle = angle + (j / 5) * (TAU / swingStages);
        const radius = outerRadius * (0.9 + RNG() * 0.2);
        const x = game.pos.x + Math.cos(particleAngle) * radius;
        const y = game.pos.y + Math.sin(particleAngle) * radius;
        const vx = Math.cos(particleAngle) * 100;
        const vy = Math.sin(particleAngle) * 100;
        createParticle(x, y, vx, vy, 0.7, '#ffd700', 6);
      }
    }
    
    // 3. Completion Explosion
    setTimeout(() => {
      // Final 360Â° explosion
      for (let i = 0; i < 24; i++) {
        const angle = (i / 24) * TAU;
        const speed = 120 + RNG() * 80;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const colors = ['#ffd700', '#ffff00', '#ffaa00'];
        const color = colors[Math.floor(RNG() * colors.length)];
        createParticle(game.pos.x, game.pos.y, vx, vy, 1.0, color, 5);
      }
    }, 300);
  }

  function tryHeavenlyBurst(){
    if (game.burstCd > 0) return;
    
    game.burstCd = CFG.player.burstCooldown;
    // cam.shake = Math.max(cam.shake, 12); // Camera shake removed
    
    // AOE damage to all demons in range
    const burstRange = CFG.player.burstRange;
    for (const z of zombies){
      const dist = Math.hypot(z.x - game.pos.x, z.y - game.pos.y);
      if (dist <= burstRange){
        const dmg = Math.round(CFG.player.burstDamage * CFG.player.upgradeMultiplier);
        z.hp -= dmg;
        game.hits++;
        // knockback
        const kb = CFG.demons.knockback * 2;
        const ang = angleTo(game.pos.x, game.pos.y, z.x, z.y);
        z.x += Math.cos(ang) * 0.6 * (kb/60);
        z.y += Math.sin(ang) * 0.6 * (kb/60);
        z.staggerT = 0.2;
      }
    }
    
    // Add heavenly burst effect
    tracers.push({x:game.pos.x, y:game.pos.y, x2:game.pos.x, y2:game.pos.y, ttl:0.5, type:'burst'});
    
    // Heavenly burst particles
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * TAU;
      const speed = 150 + RNG() * 100;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const colors = ['#ffffff', '#ffff00', '#ffaa00'];
      const color = colors[Math.floor(RNG() * colors.length)];
      createParticle(game.pos.x, game.pos.y, vx, vy, 0.8, color, 4);
    }
  }



  function upgradeWeapon(){
    if (game.upgradeLevel >= CFG.progression.maxUpgrades) return;
    
    game.upgradeLevel++;
    
    // Increase damage multiplier
    CFG.player.upgradeMultiplier = 1.0 + (game.upgradeLevel * 0.2);
    
    // Visual feedback
    // cam.shake = Math.max(cam.shake, 8); // Camera shake removed
    
    // Upgrade particles
    for (let i = 0; i < 15; i++) {
      const angle = (i / 15) * TAU;
      const speed = 120 + RNG() * 80;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      createParticle(game.pos.x, game.pos.y, vx, vy, 1.0, '#ffff00', 4);
    }
  }

  function explodeDemon(z, x, y) {
    const demonType = CFG.demons[z.type];
    if (!demonType.explodeOnContact) return;
    
    // Multi-stage explosion
    const explosionRadius = demonType.explosionRadius;
    const explosionDamage = demonType.explosionDamage;
    
    // Stage 1: Flash
    for (let i = 0; i < 25; i++) {
      const angle = (i / 25) * TAU;
      const speed = 400 + RNG() * 300;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      createParticle(x, y, vx, vy, 0.4, '#ffffff', 8);
    }
    
    // Stage 2: Shockwave
    for (let i = 0; i < 40; i++) {
      const angle = (i / 40) * TAU;
      const speed = 200 + RNG() * 150;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const colors = ['#ff4400', '#ff6600', '#ff8800', '#ff2200'];
      const color = colors[Math.floor(RNG() * colors.length)];
      createParticle(x, y, vx, vy, 1.0, color, 6);
    }
    
    // Stage 3: Blood explosion - Enhanced for hyper-realism
    for (let i = 0; i < 35; i++) {
      const angle = (i / 35) * TAU;
      const speed = 120 + RNG() * 100;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const colors = ['#8b0000', '#ff0000', '#dc143c', '#660000', '#440000'];
      const color = colors[Math.floor(RNG() * colors.length)];
      createParticle(x, y, vx, vy, 2.0, color, 4);
    }
    
    // Stage 4: Gore particles - New scary effect
    for (let i = 0; i < 20; i++) {
      const angle = (i / 20) * TAU;
      const speed = 80 + RNG() * 60;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const colors = ['#330000', '#220000', '#110000'];
      const color = colors[Math.floor(RNG() * colors.length)];
      createParticle(x, y, vx, vy, 3.0, color, 5);
    }
    
    // Create enhanced blood pools on the ground - More realistic
    for (let i = 0; i < 5; i++) {
      const offsetX = (RNG() - 0.5) * 60;
      const offsetY = (RNG() - 0.5) * 60;
      createBloodPool(x + offsetX, y + offsetY);
    }
    
    // Damage to Michael if in range
    const distToMichael = Math.hypot(x - game.pos.x, y - game.pos.y);
    if (distToMichael <= explosionRadius) {
      // Roll immunity - no damage during roll
      if (!game.rolling) {
        // Explosion damage scales with upgrade level (reduced damage)
        const damageReduction = 1.0 - (game.upgradeLevel * 0.1);
        const damage = Math.round(explosionDamage * damageReduction * (1 - distToMichael / explosionRadius));
        applyDamage(damage);
        // Enhanced screen shake based on explosion size
        // const shakeIntensity = Math.max(15, explosionRadius * 0.3);
        // cam.shake = Math.max(cam.shake, shakeIntensity);
      }
    }
    
    // Damage to other demons in range
    for (const otherZ of zombies) {
      if (otherZ === z) continue;
      const dist = Math.hypot(x - otherZ.x, y - otherZ.y);
      if (dist <= explosionRadius) {
        const damage = Math.round(explosionDamage * 0.5 * (1 - dist / explosionRadius));
        otherZ.hp -= damage;
        if (otherZ.hp <= 0) {
          onDemonKilled(otherZ);
          const index = zombies.indexOf(otherZ);
          if (index > -1) {
            zombies.splice(index, 1);
            game.zAlive--;
          }
        }
      }
    }
  }

  // Reload function removed - not needed for divine weapons



  function spawnDemon(type){
    const tcfg = CFG.demons[type] || CFG.demons.imp;
    // Spawn in circular pattern around Michael
    const angle = RNG() * TAU;
    const distance = 200 + RNG() * 300; // 200-500 units away (closer spawns)
    const x = game.pos.x + Math.cos(angle) * distance;
    const y = game.pos.y + Math.sin(angle) * distance;
    
    // ensure not too close but not too far
    const away = Math.hypot(x-game.pos.x,y-game.pos.y);
    if (away < 200 || away > 600) { return spawnDemon(type); }

    const scaleHP = 1 + CFG.waves.hpScale * game.wave;
    zombies.push({
      x,y, vx:0,vy:0, sp:tcfg.spd*(0.9+RNG()*0.2), rad:tcfg.rad,
      hp: Math.round(tcfg.hp*scaleHP), type, staggerT:0
    });
  }

  function onDemonKilled(z){
    game.kills++;
    game.totalKills++;
    
    // DEMONS EXPLODE WHEN KILLED - Enhanced death effects
    const demonType = CFG.demons[z.type];
    if (demonType) {
      // Create explosion at demon's death location
      explodeDemon(z, z.x, z.y);
      
      // Additional death particles for extra gore
      for (let i = 0; i < 15; i++) {
        const angle = (i / 15) * TAU;
        const speed = 100 + RNG() * 80;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const colors = ['#8b0000', '#ff0000', '#dc143c', '#660000'];
        const color = colors[Math.floor(RNG() * colors.length)];
        createParticle(z.x, z.y, vx, vy, 2.0, color, 4);
      }
      
      // Create blood pools at death location
      for (let i = 0; i < 4; i++) {
        const offsetX = (RNG() - 0.5) * 50;
        const offsetY = (RNG() - 0.5) * 50;
        createBloodPool(z.x + offsetX, z.y + offsetY);
      }
    }
    
    // No more Divine Favor system - demons just die and explode
  }
  
  function chooseDemonType(totalKills) {
    // Progressive demon mix based on total kills
    const mixImp = lerp(0.70, 0.30, clamp(totalKills/100, 0, 1));
    const mixHellhound = lerp(0.25, 0.45, clamp(totalKills/100, 0, 1));
    const mixFallen = lerp(0.05, 0.25, clamp(totalKills/100, 0, 1));
    
    // Create spawn bag for this spawn
    const spawnBag = [];
    const addType = (t, count) => { for(let i=0; i<count; i++) spawnBag.push(t); };
    addType('imp', Math.round(10*mixImp));
    addType('hellhound', Math.round(10*mixHellhound));
    addType('fallen', Math.round(10*mixFallen));
    
    // Return random demon type from bag
    return spawnBag[Math.floor(RNG() * spawnBag.length)] || 'imp';
  }
  function applyDamage(dmg){
    game.hp -= dmg;
  }

  // No physics needed - demons pass through everything

  // Rendering
  function render(){
    // Resize backing store if needed
    if (canvas.width !== Math.floor(W*DPR) || canvas.height !== Math.floor(H*DPR)){
      canvas.width = Math.floor(W*DPR);
      canvas.height = Math.floor(H*DPR);
    }
    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Camera transform
    const shakeX = (RNG()*2-1)*cam.shake;
    const shakeY = (RNG()*2-1)*cam.shake;
    const cx = canvas.width/2, cy = canvas.height/2;
    ctx.translate(cx + shakeX, cy + shakeY);
    ctx.scale(cam.zoom, cam.zoom);
    ctx.translate(-cam.x, -cam.y);

    // Dynamic hell background - darker and scarier
    const time = performance.now() * 0.001;
    const glowIntensity = 0.2 + 0.05 * Math.sin(time * 1.5);
    ctx.fillStyle = `rgba(80,20,20,${glowIntensity * 0.15})`;
    ctx.fillRect(-CFG.arena.w/2, -CFG.arena.h/2, CFG.arena.w, CFG.arena.h);
    
    // Arena floor grid
    drawArena();

    // No obstacles - demons spawn freely

    // Drops removed - no more collectibles

    // Weapon effects
    for (const tr of tracers){
      if (tr.type === 'decimateHandle') {
        // Decimate handle effect - inner circle (dull gray)
        ctx.strokeStyle = `rgba(100,100,100,${clamp(tr.ttl/0.4,0,1)})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(tr.x, tr.y);
        ctx.lineTo(tr.x2, tr.y2);
        ctx.stroke();
      } else if (tr.type === 'decimateBlade') {
        // Decimate blade effect - outer circle (golden with glow)
        ctx.strokeStyle = `rgba(255,215,0,${clamp(tr.ttl/0.5,0,1)})`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(tr.x, tr.y);
        ctx.lineTo(tr.x2, tr.y2);
        ctx.stroke();
        
        // Blade glow effect
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else if (tr.type === 'burst') {
        // Heavenly burst effect - expanding circle
        ctx.save();
        ctx.translate(tr.x, tr.y);
        const radius = (1 - tr.ttl/0.5) * 100;
        ctx.strokeStyle = `rgba(255,255,255,${clamp(tr.ttl/0.5,0,1)})`;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(0,0, radius, 0, TAU);
        ctx.stroke();
        ctx.restore();
      } else if (tr.type === 'holyEmber') {
        // Holy Ember Spin effect - expanding ring
        ctx.save();
        ctx.translate(tr.x, tr.y);
        const radius = (1 - tr.ttl/0.6) * 300;
        ctx.strokeStyle = `rgba(255,170,0,${clamp(tr.ttl/0.6,0,1)})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0,0, radius, 0, TAU);
        ctx.stroke();
        ctx.restore();
      } else {
        // Default tracer
        ctx.strokeStyle = `rgba(200,235,255,${clamp(tr.ttl/0.06,0,1)})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(tr.x, tr.y); ctx.lineTo(tr.x2, tr.y2); ctx.stroke();
      }
    }

    // Demons
    for (const z of zombies){
      ctx.save();
      ctx.translate(z.x, z.y);
      
      // Demon glow effect
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 10;
      
      // body
      ctx.beginPath();
      ctx.arc(0,0, z.rad, 0, TAU);
      if (z.type === 'fallen') {
        ctx.fillStyle = '#8d3a3a'; // Dark red
      } else if (z.type === 'hellhound') {
        ctx.fillStyle = '#7a3a3a'; // Darker red
      } else {
        ctx.fillStyle = '#5b3a3a'; // Darkest red
      }
      ctx.fill();
      
      // Demon eyes
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(-z.rad*0.3, -z.rad*0.2, 3, 0, TAU);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(z.rad*0.3, -z.rad*0.2, 3, 0, TAU);
      ctx.fill();
      
      // health ring
      const hpPct = clamp(z.hp / (CFG.demons[z.type]?CFG.demons[z.type].hp*(1+CFG.waves.hpScale*game.wave):100), 0, 1);
      ctx.beginPath();
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = 3;
      ctx.arc(0,0, z.rad+4, -Math.PI/2, -Math.PI/2 + hpPct*TAU);
      ctx.stroke();
      
      ctx.restore();
    }

    // Particles
    renderParticles();
    
    // Blood pools
    renderBloodPools();
    
    // Player
    ctx.save();
    ctx.translate(game.pos.x, game.pos.y);
    
    // Roll visual effects
    if (game.rolling) {
      // Add blur trail effect
      const rollProgress = 1 - (game.rollT / (CFG.player.rollDistance / CFG.player.rollSpeed));
      const trailLength = 40;
      const trailSteps = 5;
      
      for (let i = 0; i < trailSteps; i++) {
        const alpha = (1 - i / trailSteps) * 0.3;
        const offset = i * (trailLength / trailSteps);
        ctx.save();
        ctx.translate(-game.rollDir.x * offset, -game.rollDir.y * offset);
        ctx.rotate(game.ang);
        ctx.globalAlpha = alpha;
        // Rolling player is cyan/electric blue
        ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
        roundRect(-18,-14,36,28,8);
        ctx.fillStyle = `rgba(100, 255, 255, ${alpha})`;
        roundRect(10,-5,26,10,5);
        ctx.restore();
      }
      
      // Main rolling player (brighter)
      ctx.rotate(game.ang + rollProgress * TAU * 2); // Spin effect
      ctx.fillStyle = '#00ffff'; // Bright cyan when rolling
      ctx.shadowColor = '#00ffff';
      ctx.shadowBlur = 15;
      roundRect(-18,-14,36,28,8);
      ctx.fillStyle = '#66ffff';
      roundRect(10,-5,26,10,5);
    } else {
      // Normal player - Michael the Archangel
      ctx.rotate(game.ang);
      ctx.fillStyle = '#ffd700'; // Golden
      roundRect(-18,-14,36,28,8);
      ctx.fillStyle = '#ffed4e'; // Bright gold
      roundRect(10,-5,26,10,5);
    }
    
    // Weapon indicator
    if (!game.rolling){
      ctx.strokeStyle = (game.currentWeapon === 'sword') ? 'rgba(255,215,0,0.8)' : 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(60,0, 16, 0, TAU); ctx.stroke();
    }
    ctx.restore();

    ctx.restore();

    // Overlays visibility managed by state
  }

  function drawArena(){
    // Hell arena frame - much darker
    const halfW = CFG.arena.w/2, halfH = CFG.arena.h/2;
    ctx.fillStyle = '#0a0404'; // Much darker red
    roundRect(-halfW, -halfH, CFG.arena.w, CFG.arena.h, 20);
    ctx.fill();

    // Hell grid with fire effect - darker
    ctx.strokeStyle = '#1a0808'; // Darker red grid
    ctx.lineWidth = 1;
    const step = 80;
    ctx.beginPath();
    for (let x = -halfW; x<=halfW; x+=step){ ctx.moveTo(x, -halfH); ctx.lineTo(x, halfH); }
    for (let y = -halfH; y<=halfH; y+=step){ ctx.moveTo(-halfW, y); ctx.lineTo(halfW, y); }
    ctx.stroke();

    // Floating hell platforms (visual only) - darker
    ctx.fillStyle = '#1a0808';
    ctx.strokeStyle = '#2a1010';
    ctx.lineWidth = 2;
    
    // Platform 1
    roundRect(-300, -200, 200, 40, 15);
    ctx.fill();
    ctx.stroke();
    
    // Platform 2
    roundRect(200, 150, 180, 35, 12);
    ctx.fill();
    ctx.stroke();
    
    // Platform 3
    roundRect(-150, 250, 160, 30, 10);
    ctx.fill();
    ctx.stroke();

    // Hell border with fire glow
    ctx.strokeStyle = '#8b0000'; // Dark red border
    ctx.lineWidth = 6;
    roundRect(-halfW, -halfH, CFG.arena.w, CFG.arena.h, 20);
    ctx.stroke();
    
    // Fire glow effect
    ctx.shadowColor = '#ff4400';
    ctx.shadowBlur = 20;
    ctx.strokeStyle = '#ff6600';
    ctx.lineWidth = 2;
    roundRect(-halfW, -halfH, CFG.arena.w, CFG.arena.h, 20);
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  function updateHUD(){
    // Update kill counter
    hud.zleft.textContent = game.totalKills;
    
    // Circular Health Meter
    const healthPercent = Math.round(100*game.hp/game.hpMax);
    const healthAngle = (healthPercent / 100) * 360;
    hud.hpBar.style.setProperty('--fill-angle', healthAngle + 'deg');
    
    // Add/remove full class for glow effect
    const healthMeter = document.querySelector('.health-meter');
    if (healthPercent >= 95) {
      healthMeter.classList.add('full');
    } else {
      healthMeter.classList.remove('full');
    }
    
    // Circular Fury Meter
    const furyPercent = Math.round(100*game.fury/100);
    const furyAngle = (furyPercent / 100) * 360;
    hud.furyBar.style.setProperty('--fill-angle', furyAngle + 'deg');
    
    // Add/remove full class for glow effect
    const furyMeter = document.querySelector('.fury-meter');
    if (furyPercent >= 95) {
      furyMeter.classList.add('full');
    } else {
      furyMeter.classList.remove('full');
    }
  }

  // Helpers
  function onResize(){
    W = window.innerWidth|0; H = window.innerHeight|0;
    DPR = Math.min(2, window.devicePixelRatio||1);
  }
  function screenToWorld(sx,sy,cb){
    const cx = canvas.width/2, cy = canvas.height/2;
    const x = (sx - cx) / cam.zoom + cam.x;
    const y = (sy - cy) / cam.zoom + cam.y;
    cb(x,y);
  }
  function roundRectPath(x,y,w,h,r){
    const rr = Math.min(r, Math.abs(w)/2, Math.abs(h)/2);
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
  }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); roundRectPath(x,y,w,h,r); ctx.fill(); }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(RNG()* (i+1))|0; const t=a[i]; a[i]=a[j]; a[j]=t; } }

  // Particle system
  function createParticle(x, y, vx, vy, life, color, size) {
    // Particle culling - limit total particles for performance
    if (particles.length >= 300) return; // Increased from 200 for enhanced effects
    
    particles.push({
      x, y, vx, vy, life, lifeMax: life, color, size
    });
  }

  function updateParticles(dt) {
    try {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        if (!p || typeof p.x !== 'number' || typeof p.y !== 'number') {
          particles.splice(i, 1);
          continue;
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    } catch (error) {
      console.warn('Particle update error:', error);
      particles.length = 0; // Reset on error
    }
  }

  function renderParticles() {
    for (const p of particles) {
      const alpha = p.life / p.lifeMax;
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(0, 0, p.size * alpha, 0, TAU);
      ctx.fill();
      ctx.restore();
    }
  }

  function createBloodPool(x, y) {
    // Blood pool limits for performance - increased for more blood
    if (bloodPools.length >= 200) return;
    
    bloodPools.push({
      x, y, 
      size: 20 + RNG() * 25, // Larger, more varied blood pools
      life: 999999, // Permanent blood - never fades
      lifeMax: 999999,
      type: RNG() < 0.3 ? 'splatter' : 'pool', // Different blood types
      intensity: 0.7 + RNG() * 0.3 // Varying blood intensity
    });
  }

  function updateBloodPools(dt) {
    // Blood pools are now permanent - no fading
    // Only update for visual effects, not removal
    for (const pool of bloodPools) {
      // Blood pools stay forever - no life reduction
      // pool.life -= dt * 0.1; // REMOVED - Blood is permanent
      
      // No removal - blood stays forever
      // if (pool.life <= 0) {
      //   bloodPools.splice(i, 1);
      // }
    }
  }

  function renderBloodPools() {
    for (const pool of bloodPools) {
      const alpha = 0.8; // Fixed alpha for permanent blood
      ctx.save();
      ctx.translate(pool.x, pool.y);
      ctx.globalAlpha = alpha * pool.intensity;
      
      // Enhanced blood rendering with 3D effects
      if (pool.type === 'splatter') {
        // Blood splatter effect
        ctx.fillStyle = '#660000';
        ctx.beginPath();
        ctx.arc(0, 0, pool.size * 0.8, 0, TAU);
        ctx.fill();
        
        // Inner darker core
        ctx.fillStyle = '#440000';
        ctx.beginPath();
        ctx.arc(0, 0, pool.size * 0.5, 0, TAU);
        ctx.fill();
        
        // Blood edge highlights
        ctx.strokeStyle = '#880000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, pool.size, 0, TAU);
        ctx.stroke();
      } else {
        // Blood pool effect
        ctx.fillStyle = '#8b0000';
        ctx.beginPath();
        ctx.arc(0, 0, pool.size, 0, TAU);
        ctx.fill();
        
        // 3D depth effect
        ctx.fillStyle = '#660000';
        ctx.beginPath();
        ctx.arc(0, 0, pool.size * 0.7, 0, TAU);
        ctx.fill();
        
        // Blood shine effect
        ctx.fillStyle = '#aa0000';
        ctx.beginPath();
        ctx.arc(0, 0, pool.size * 0.3, 0, TAU);
        ctx.fill();
      }
      
      ctx.restore();
    }
  }

  // Gamepad state
  let padMove={x:0,y:0}, padSprint=false, padFire=false, padDecimate=false;
  function readGamepad(){
    const pads = navigator.getGamepads ? navigator.getGamepads() : [];
    const gp = pads && pads[0];
    if (!gp) { usingPad=false; padMove.x=padMove.y=0; padAim.x=padAim.y=0; padFire=padDecimate=padSprint=false; return; }
    usingPad = true;
    // Axes: 0,1 = LS; 2,3 or 2,5 = RS depending browser
    const ax = gp.axes || [];
    const lsX = dead(ax[0]||0), lsY = dead(ax[1]||0);
    const rsX = dead(ax[2]||0), rsY = dead(ax[3] ?? ax[5] ?? 0);
    padMove.x = lsX; padMove.y = lsY;
    padAim.x = rsX; padAim.y = rsY;
    // Buttons: RT=7, LT=6, LB=4, X=2, A=0
    padFire = (gp.buttons[7] && gp.buttons[7].pressed) || false;
    padDecimate = (gp.buttons[6] && gp.buttons[6].pressed) || false; // LT for Decimate
    padSprint = (gp.buttons[1] && gp.buttons[1].pressed) || false; // B as sprint


    // Heavenly burst
    if (gp.buttons[5] && gp.buttons[5].pressed) tryHeavenlyBurst();
    // Upgrade weapon (RB button)
    if (gp.buttons[3] && gp.buttons[3].pressed) upgradeWeapon();
    // No menu/shop states in pure gameplay mode
  }
  function dead(v){ const d=0.2; return Math.abs(v)<d ? 0 : v; }


  // Expose for debugging
  window._game = game; window._z= zombies;

})();
</script>
</body>
</html>


